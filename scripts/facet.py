"""Script that allows you to create an stl file from a set of X, Y and Z coordinates.
The basis of an stl file is a facet composed of three points and its orthonormal vector.
The Facet() class has 2 methods to create, from three points:
    - the orthonormal vector (noramlFacet(self))
    - the corresponding stl string (stringFacet(self))
The stl file thus obtained allows the visualization of the surface. On the other hand, it cannot always be used in a 3D printer slicer. This will be possible if the surface is closed, continuous. On the other hand, if, for an altitude z, the curve (x(z), y(z)) is discontinuous, the stl file will be considered invalid by the slicer. To remedy this problem, it is necessary to give a thickness (offset) to the surface so as to make the curve (x(z), y(z)) continuous. This requires the creation of new facets for the offset but also for the 3 diamonds which will join 2 by 2 the points of the initial triangle and those of the offset triangle. For this reason, 2 other methods are put in place:
    - offsetFacet(self, offset)
    - aroundFacet(self, offset)
Other methods, outside of class, are available:
    - format_e(x) which formats numbers in scientific writing, with 10 significant digits
    - stringVertex(triplet) which returns the stl string for a given vertex
    - stringNormal(triplet) which returns the string of the orthonormal vector
    - stringListFacet(listFacet) which returns the stl string from a list of Facet()
    - surface2Facet(X, Y, Z) which returns the list of Facet() for a given surface
    - surface2AllFacets(X, Y, Z, offset) which returns the list of Facet() for a given surface and the points generated by the offset
    - stlSingleSurface(X, Y, Z, name) returns the stl string for a surface WITHOUT offset; name is the name given to the surface
    - stlAllSurface(X, Y, Z, offset, name) returns the stl string for a surface WITH offset
The number of Facets being multiplied by 8 to go from a surface without offset to a surface with offset, the file with offset can be large."""

"""Script qui permet de créer un fichier stl à partir d'un jeu de coordonnées X, Y et Z.
La base d'un fichier stl est une facette (Facet) composée de trois points et de son vecteur orthonormé.
La classe Facet() dipose de 2 méthodes pour créer, à partir de trois points :
    - le vecteur orthonormé (noramlFacet(self))
    - le string stl correspondant (stringFacet(self))
Le fichier stl ainsi obtenu permet la visualisation de la surface. Par contre il ne pourra pas toujours être utilisé dans un slicer d'imprimante 3D. Ceci sera possible si la surface est fermée, continue. Par contre si, pour une altitude z, la courbe (x(z), y(z))est discontinue, le fichier stl sera considéré comme invalide par le slicer. Pour remédier à ce problème, il convient de donner une épaisseur (offset) à la surface de façon à rendre la courbe (x(z), y(z)) continue. Ceci nécessite la création de nouvelles facettes pour l'offset mais aussi pour les 3 losanges qui vont joindre 2 à 2 les points du triangle initial et ceux du triangle offset. Pour cette raison, 2 autres méthodes sont mises en place:
    - offsetFacet(self, offset)
    - aroundFacet (self, offset)
D'autres méthodes, hors classe, sont disponibles :
    - format_e(x) qui formate les nombres en écriture scientifiques, avec 10 chiffres significatifs
    - stringVertex(triplet) qui renvoie le string stl pour un sommet donné
    - stringNormal(triplet) qui renvoie le string du vecteur orthonormé
    - stringListFacet(listFacet) qui renvoie le string stl à partir d'une liste de Facet()
    - surface2Facet(X, Y, Z) qui renvoie la liste de Facet() pour une surface donnée
    - surface2AllFacets(X, Y, Z, offset) qui renvoie la liste de Facet() pour une surface donnée et les points générés par l'offset
    - stlSingleSurface(X, Y, Z, name) renvoie le string stl pour une surface SANS offset ; name est le nom donné à la surface
    - stlAllSurface(X, Y, Z, offset, name) renvoie le string stl pour une surface AVEC offset
Le nombre de Facet étant multiplié par 8 pour passer d'une surface sans offset à une surface avec offset, le fichier avec offset peut être volumineux.
"""

import numpy as np

class Facet:
    Vector = list[float, float, float]
    def __init__(self, P1: Vector, P2: Vector, P3: Vector):
        """P1, P2, P3 sont des points dans l'espcace : liste de trois float"""
        """P1, P2, P3 are points in space: list of three floats"""
        self.P1 = np.asarray(P1)
        self.P2 = np.asarray(P2)
        self.P3 = np.asarray(P3)

    def __repr__(self) -> str:
        return f'{self.P1}, {self.P2}, {self.P3}'
    
    def normalFacet(self):
        """Renvoie le vecteur unitaire normal à la face Facet()"""
        """Returns the unit normal vector to the facet Facet()"""
        
        try:
            V1 = self.P2 - self.P1
            V2 = self.P3 - self.P1
            cross = np.cross(V1, V2)
            norm = np.linalg.norm(cross)
            if norm == 0:
                pass
            else:
                return cross / norm
        except:
            pass

    def offsetFacet(self, offset):
        """Renvoie une facette décalée de la valeur offset à partir de la facette initiale (self)"""
        """Returns a facet shifted by the offset value from the initial facet (self)"""
        try:
            normal = self.normalFacet()
            off1 = self.P1 - offset*normal
            off2 = self.P2 - offset*normal
            off3 = self.P3 - offset*normal
            return Facet(off1, off2, off3)
        except:
            pass
        
    def aroundFacet(self, offset):
        """Renvoie les 6 triangles délimités par les points P1, P2, P3, off1, off2, off3
        Renvoie une liste de Facet"""
        """Returns the 6 triangles delimited by the points P1, P2, P3, off1, off2, off3
        Returns a list of Facet"""

        try:
            off1 = self.offsetFacet(offset).P1
            off2 = self.offsetFacet(offset).P2
            off3 = self.offsetFacet(offset).P3
            
            triangle_11 = Facet(self.P2, self.P1, off1)
            triangle_12 = Facet(self.P2, off1, off2)
            triangle_21 = Facet(self.P3, self.P2, off2)
            triangle_22 = Facet(self.P3, off2, off3)
            triangle_31 = Facet(self.P1, self.P3, off3)
            triangle_32 = Facet(self.P1, off3, off1)

            return [triangle_11, triangle_12, triangle_21, triangle_22, triangle_31, triangle_32]

        except:
            pass

    def stringFacet(self):
        """Renvoie le string complet pour une facette"""
        """Returns the full string for a facet"""

        string = stringNormal(self.normalFacet())
        string += f'    outer loop\n'
        string += stringVertex(self.P1)
        string += stringVertex(self.P2)
        string += stringVertex(self.P3)
        string += f'    endloop\n'
        string += f'endfacet\n'
        return string 
    
# Quelques fonctions utiles
# Some useful functions

def format_e(x):
    """Formate les nombres en écriture scientifique ; 10 chiffres"""
    """Formats numbers in scientific notation; 10 digits"""
    return f'{x:.10e}'

def stringVertex(triplet):
    """Renvoie le string vertex pour stl
    triplet est un triplet (float, float, float) correspondant à un point"""
    """Returns the string vertex for stl
    triplet is a triplet (float, float, float) corresponding to a point """
    return f'        vertex {format_e(triplet[0])} {format_e(triplet[1])} {format_e(triplet[2])}\n'

def stringNormal(triplet):
    """Renvoie sous forme de string les coordonnées du vecteur normalFacet, au format défini par la fonction format_e"""
    """Returns the coordinates of the normalFacet vector in the form of a string, in the format defined by the function format_e"""
    return f'facet normal {format_e(triplet[0])} {format_e(triplet[1])} {format_e(triplet[2])}\n'    

def stringListFacet(listFacet):
    """Depuis une liste de Facet, renvoie le string STL"""
    """From a list of Facets, returns the STL string"""
    string = ""
    for facet in listFacet:
        try:
            string += facet.stringFacet()
        except:
            pass
    return string

# Création de facettes à partir d'une surface
# Creation of facets from a surface

def surface2Facet(X, Y, Z):
    """X, Y et Z sont des jeux de coordonnées paramétriques (paramètres (U,V) issus d'un maillage de valeurs (u,v))
    X, Y et Z sont des numpy.array de shape (len(v), len(u))
    Renvoie les facettes Facet pour la surface considérée"""
    """X, Y and Z are sets of parametric coordinates (parameters (U,V) resulting from a mesh of values ​​(u,v))
    X, Y and Z are numpy.arrays of shape (len(v), len(u))
    Returns the Facet facets for the considered surface"""
    lenV = X.shape[0]
    lenU = X.shape[1]
    facets = []
    try: 
        for i in range(0, lenV - 1):
            for j in range(0, lenU - 1):
                print(f'{i}/{lenV} - {j}/{lenU}')
                """Si on a quatre points P0, P1, P2 et P3 qui forment un losange tournant dans le sens trigonométrique :
                P0 est en indice i, j
                P1 est en indice i, j+1 
                P2 est en indice i+1, j+1
                P3 est en indice i+1, j
                On crée le deux facettes P0P1P2 et P1P2P3"""

                """If we have four points P0, P1, P2 and P3 which form a diamond rotating in the trigonometric direction:
                P0 is in index i, j
                P1 is in index i, j+1 
                P2 is in index i+1, j+1
                P3 is in index i+1, j
                We create the two facets P0P1P2 and P1P2P3"""

                P0 = [X[i][j], Y[i][j], Z[i][j]]
                P1 = [X[i][j+1], Y[i][j+1], Z[i][j+1]]
                P2 = [X[i+1][j+1], Y[i+1][j+1], Z[i+1][j+1]]
                P3 = [X[i+1][j], Y[i+1][j], Z[i+1][j]]
                facet1 = Facet(P0, P1, P3)
                facet2 = Facet(P1, P2, P3)
                facets.append(facet1)    
                facets.append(facet2)  
    except:
        pass
    print(f'Liste créé de taille {len(facets)}\nCreated list of length {len(facets)}')            
    return facets

def surface2Offset(X, Y, Z, offset):
    print(f'Lancement de la fonction surface2offset\nLaunching the surface2Offset function')
    array = []
    print(f'Création de la liste surface2Facet\nCreating the surface2Facet list')
    facets = surface2Facet(X, Y, Z)
    print(f'Lancement de la boucle pour générer toutes les facettes\nLaunching the loop to generate all facets')
    try:
        for facet in facets:
            array.append(facet)
            try:
                off = facet.offsetFacet(offset)
                array.append(off)
            except:
                pass
            try:
                around = facet.aroundFacet(offset)
                array.extend(around)
            except:
                pass                 
    except:
        pass
    
    print(f'Liste créé de taille {len(array)}\nCreated list of length {len(array)}')
    return array

# Création de stl
# Creation of stl

def stlSingleSurface(X, Y, Z, name):
    """A partir des coordonnées X, Y, Z des points d'une surface donnée, création du stl complet pour la surface SANS offset
    name est le nom de la surface"""
    """From the X, Y, Z coordinates of the points of a given surface, creation of the complete stl for the surface WITHOUT offset
    name is the name of the surface"""

    print(f'Ecriture du stl\nLancement de la création de la liste de facettes\nWriting the stl\nStarting the creation of the list of facets')
    facets = surface2Facet(X, Y, Z)
    print(f'Ecriture du string stl\nWriting the stl string')
    string = f'solid {name}\n'
    string += stringListFacet(facets)
    string += f'endsolid {name}'
    print(f'Fin du string stl\nEnd of stl string')
    return string

def stlOffsetSurface(X, Y, Z, offset, name):
    print(f'Ecriture du stl\nLancement de la création de la liste de facettes\nWriting the stl\nStarting the creation of the list of facets')
    facets = surface2Offset(X, Y, Z, offset)
    print(f'Ecriture du string stl\nWriting the stl string')
    string = f'solid {name}\n'
    string += stringListFacet(facets)
    string += f'endsolid {name}'
    print(f'Fin du string stl\nEnd of stl string')
    return string    
